use parking_lot::Mutex;

use crate::{
    backend::perfetto::process_descriptor,
    command::Command,
    span::RawSpan,
    span_queue::add_descriptor,
    utils::{
        ring_buffer::RingBuffer,
        spsc::{bounded, Receiver, Sender},
    },
    SHARD_NUM,
};
use std::{
    cell::UnsafeCell,
    io::Write,
    sync::atomic::{AtomicBool, Ordering},
};

/// A type that consumes spans generated by each thread.
// TODO: Do we need Send + 'static bound?
pub trait SpanConsumer: Send {
    // TODO: Can spans be abstracted?
    fn consume(&mut self, spans: &[RawSpan], writer: &mut Box<&mut dyn Write>);
}

static SPSC_RXS: Mutex<Vec<Receiver<Command>>> = Mutex::new(Vec::new());

pub(crate) fn register_receiver(rx: Receiver<Command>) {
    SPSC_RXS.lock().push(rx);
}

#[inline]
pub(crate) fn send_command(cmd: Command) {
    COMMAND_SENDER
        .try_with(|sender| unsafe { (*sender.get()).send(cmd).ok() })
        .ok();
}

thread_local! {
    static COMMAND_SENDER: UnsafeCell<Sender<Command>> = {
        let (tx, rx) = bounded(10240);
        register_receiver(rx);
        UnsafeCell::new(tx)
    };
}

/// Mainly used for perfetto tracing, where we need to publish process descriptor first.
static FLUSHED_ONCE: AtomicBool = AtomicBool::new(false);

#[inline]
fn flushed_once() -> bool {
    FLUSHED_ONCE.load(Ordering::Relaxed)
}
fn set_flushed_once(set: bool) {
    FLUSHED_ONCE.store(set, Ordering::Relaxed);
}

pub(crate) static GLOBAL_SPAN_CONSUMER: Mutex<GlobalSpanConsumer> =
    Mutex::new(GlobalSpanConsumer::new());

pub(crate) struct GlobalSpanConsumer {
    pub(crate) consumer: Option<Box<dyn SpanConsumer>>,
    pub(crate) command_buf: Option<RingBuffer<Command>>,
}

impl GlobalSpanConsumer {
    const fn new() -> Self {
        Self {
            consumer: None,
            command_buf: None,
        }
    }

    pub(crate) fn collect_and_push_commands(&mut self) {
        let mut guard = SPSC_RXS.lock();
        let rxs = &mut *guard;

        for rx in rxs {
            while let Ok(Some(command)) = rx.try_recv() {
                self.push_overwrite(command);
            }
        }
    }

    fn push_overwrite(&mut self, command: Command) {
        self.command_buf
            .get_or_insert_with(|| RingBuffer::new(SHARD_NUM.load(Ordering::Relaxed) * 2))
            .push_overwrite(command);
    }

    pub(crate) fn flush(&mut self, writer: &mut Box<&mut dyn Write>) {
        let Some(_consumer) = &mut self.consumer else {
            panic!("Consumer should be set");
        };

        // Required for perfetto tracing.
        // TODO: Can we put this logic elsewhere?
        if !flushed_once() {
            add_descriptor(process_descriptor());
            set_flushed_once(true);
        }

        let Some(spans) = self.command_buf.as_mut().map(|buf| {
            buf.drain()
                .into_iter()
                .map(|cmd| match cmd {
                    Command::SendSpans(spans) => spans,
                })
                .collect::<Vec<_>>()
        }) else {
            return;
        };

        for spans in &spans {
            self.consumer.as_mut().unwrap().consume(spans, writer);
        }
    }
}
