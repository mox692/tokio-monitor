use parking_lot::Mutex;

use crate::{
    backend::perfetto::process_descriptor,
    command::Command,
    span::RawSpan,
    utils::{
        ring_buffer::RingBuffer,
        spsc::{bounded, Receiver, Sender},
    },
    SHARD_NUM,
};
use std::{
    cell::UnsafeCell,
    sync::atomic::{AtomicBool, Ordering},
};

/// A type that consumes spans generated by each thread.
// TODO: Do we need Send + 'static bound?
pub trait SpanConsumer: Send {
    // TODO: Can spans be abstracted?
    fn consume(&mut self, spans: &[RawSpan]);
}

static SPSC_RXS: Mutex<Vec<Receiver<Command>>> = Mutex::new(Vec::new());

pub(crate) fn register_receiver(rx: Receiver<Command>) {
    SPSC_RXS.lock().push(rx);
}

#[inline]
pub(crate) fn send_command(cmd: Command) {
    COMMAND_SENDER
        .try_with(|sender| unsafe { (*sender.get()).send(cmd).ok() })
        .ok();
}

thread_local! {
    static COMMAND_SENDER: UnsafeCell<Sender<Command>> = {
        let (tx, rx) = bounded(10240);
        register_receiver(rx);
        UnsafeCell::new(tx)
    };
}

/// Mainly used for perfetto tracing, where we need to publish process descriptor first.
static FLUSHED_ONCE: AtomicBool = AtomicBool::new(false);

#[inline]
fn flushed_once() -> bool {
    FLUSHED_ONCE.load(Ordering::Relaxed)
}
fn set_flushed_once(set: bool) {
    FLUSHED_ONCE.store(set, Ordering::Relaxed);
}

pub(crate) static GLOBAL_SPAN_CONSUMER: Mutex<GlobalSpanConsumer> =
    Mutex::new(GlobalSpanConsumer::new());

pub(crate) struct GlobalSpanConsumer {
    pub(crate) consumer: Option<Box<dyn SpanConsumer>>,
    pub(crate) command_buf: Option<RingBuffer<Command>>,
}

impl GlobalSpanConsumer {
    const fn new() -> Self {
        Self {
            consumer: None,
            command_buf: None,
        }
    }

    pub(crate) fn collect_and_push_commands(&mut self) {
        let mut guard = SPSC_RXS.lock();
        let rxs: Vec<Receiver<Command>> = guard.drain(..).collect();
        drop(guard);

        for mut rx in rxs {
            while let Ok(Some(command)) = rx.try_recv() {
                self.push_overwrite(command);
            }
        }
    }

    pub(crate) fn push_overwrite(&mut self, command: Command) {
        self.command_buf
            .get_or_insert_with(|| RingBuffer::new(SHARD_NUM.load(Ordering::Relaxed) * 2))
            .push_overwrite(command);
    }

    pub(crate) fn flush(&mut self) {
        let Some(consumer) = &mut self.consumer else {
            panic!("Consumer should be set");
        };

        // Required for perfetto tracing.
        // TODO: Can we put this logic elsewhere?
        if !flushed_once() {
            consumer.as_mut().consume(&[process_descriptor()]);
            set_flushed_once(true);
        }

        let spans: Vec<RawSpan> = self
            .command_buf
            .get_or_insert_with(|| RingBuffer::new(SHARD_NUM.load(Ordering::Relaxed) * 2))
            .drain()
            .into_iter()
            .flat_map(|cmd| match cmd {
                Command::SendSpans(spans) => spans,
            })
            .collect();

        self.consumer.as_mut().unwrap().consume(&spans);
    }
}
